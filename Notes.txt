# Spring Security
- when you add spring security by default a password will be generated for logging in
    to any request username: user
                   password: <generated and printed in console>
- when you visit any endpoint it will redirect you to localhost:8080/login page
    and in the login form, if you inspect you will see there is an input tag
    which has hidden _csrf attribute for "csrf attack". which is generated by server
    every time the page is loaded
    <input name="_csrf" type="hidden" value="YsUMoL0m7-cmYGwyPwRbAMPFaXA4sptC2wgl--qttUq0EyuYWv06lIwe2oULAg9QWylvMqbxREhdhv5vuWoSy9yehXqEIEj8">

- in application/storage of browser dev tools - you will find cookies or session details
- in network tab - you will find after clicking sign in - in payload _csrf token

# custome user and pass for spring basic security
spring.security.user.name=app
spring.security.user.password=pass
spring.security.user.roles[]={ADMIN, DEV, USER}

# Internal Working of Spring Security
1. incoming request --> FilterChain --> DelegatingFilterProxy --> FilterChainProxy
2. SecurityFilterChain: (fill data in spring security context from headers or request)
    - UsernamePasswordAuthenticationFilter
    - WebAsyncManagerIntegrationFilter
    - SecuritycontextPersistenceFilter
    - LogoutFilter
    - HeaderWriterFilter
    - etc
authentication responsibility is delegated
    |
3. Authentication Manager (return the authenticated user to filter)
    |
4. ProviderManager --> Authentication Provider (return the authenticated user to authentication manager)
    - DaoAuthenticationProvider
    - InMemoryAuthenticationPRovider
    - OAuth2AuthenticationProvider
    - etc
5. e.g DaoAuthenticationProvider
        |
6. UserDetailService(authenticate from DB) & PasswordEncoder
7. Security Filter will then call SecurityContextHolder
    set Authenticated user in context - SecurityContextHolder(SecurityContext)
         |
8. Dispatcher Servlet and controllers

# Steps for DaoAuthencation
1. user entity and implements UserDetails (getpassword, getUsername, getAuthorities)
2. create user repository with this method Optional<User> findByEmail();
3. create UserService implements UserDetailsService and implement the loadUserByUsername method
   - springProvider(authentication provider) will use this method to get the user from repository

InMemoryUserDetailManager: (users that we define in application.properties file)
    - The InMemoryUserDetailManager is a spring security provided implementation of
      UserDetailsService that stores user information in memory.
    - purpose: To store user details in memory, typically for testing or small application.
               you define users directly in the configuration.

4. PasswordEncoder:
    - The passwordEncoder interface is used for encoding and validating passwords.
      It has methods for encoding raw passwords and matching encoded passwords.
    - purpose: to securely hash passwords before storing them and to verify hashed passwords
               during authentication.
    - common implementations:
        - BCryptPasswordEncoder
        - Pbkdf2PasswordEncoder
        - SCryptPasswordEncoder

# SecurityFilterChain: (corsFilter, csrfFilter, logoutfilter, usernamePasswordAuthenticationFilter, BearerTokenAuthenticationFilter etc..)

# Creating out own FilterChain
1. create a WebSecurityConfig class in config package with annotations
    - @Configuration
    - @EnableWebSecurity
2. create bean of SecurityFilterChain:
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        // authorizeHttpRequests - here we define which requests to authenticate to
        // auth.requestMatchers("/posts/**").permitAll().anyRequest().authenticated()
        // or auth.requestMatchers("/posts/**").hasAnyRole("ADMIN", "DEV")
        // in formLogin we can define custome login page
        // if you disable session then everytime you have to login without any other authenticatio like jwt and all
        httpSecurity
                        .authorizeHttpRequests(auth -> auth
                                .requestMatchers("/posts").permitAll()
                                .requestMatchers("/posts/**").hasAnyRole("ADMIN")
                                .anyRequest().authenticated())
                        .csrf(csrfConfig -> csrfConfig.disable())
                        .sessionManagement(sessionConfig -> sessionConfig
                                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                        .formLogin(Customizer.withDefaults());
                return httpSecurity.build();
    }

# JWT - represents claims to be transferred between two parties
- Jwt is often used to transmit non-sensitive data that doesn't require confidentiality
  but still needs integrity and authenticity. This includes user identifiers, roles,
  permissions, and other claims necessary for making access control decisions.
1. stateless
2. scalable in distributed systems (each server can verify jwt, better than csrf - not sure in which server the csrf is stored in which server)
3. cross domain authentication (test.hello.com, www.hello.in, etc)
4. ideal for decentralized systems and microservices
5. Highly secure

# JWT consists of
    - Header
    - Payload
    - Signature
e.g (Header)      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
    (payload)    .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0
    (signature)  .KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
Header:
{
  "alg": "HS256",
  "typ": "JWT"
}
payload:
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}
signature:
a-string-secret-at-least-256-bits-long

# JWT - creation
- Encoded Header in base 64url
- Encoded Payload in base 64url
- secrete key - available at the point of token generation - HMAC-SHA256 - base 64url
- concat with '.' -> token

# Flow of JWT
       __________login req______ api generates JWT using secret key
client __________return jwt_____________/     /
    |_____ further req done with jwt ________/

# Dependencies required for jwt
        <!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.6</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-jackson -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>

# steps for JWT configuration
1. create service for jwt
    - JwtService - two method (create and verity token)
2. create bean for AuthenticationManager
3. create AuthController
4. create AuthService

5. creating jwtfilter before any other filter using chain.doFilter()


# Authentication Exception(parent)
AuthenticationException contians several exceptions, use HttpStatus 401 - Unauthorized to handle the response:
- AccountExpiredException
- BadCredentialsException
- CredentialsExpiredException
- AuthenticationCredentialsNotFoundException
- SessionAuthenticationException

# Authorization Exception(parent)

# JWT Exception(parent)
- ExpiredJwtException
- MalformedJwtException
- SignatureException
- UnsupportedJwtException
- IllegalArgumentException

JwtException - cannot be used with as we used authenticationException in global exception handler
because the exception is not present in dispatcherservelt
so we need to use HandlerExceptionResolver in jwtAuthFilter.


# Refresh Token - e.g Netflix, Instagram, gmail etc
Use Two token instead of one ( as token expire quickly):
1. Access Token (response) -  short lived (5 - 10 min) - used to access the requests but along with that validate the refresh token
2. Refresh Token(cookie) - long lived (more than a month) lets say

- if access token is not verified use refresh token to get access token
-


# Configure OAuth2
- add dependency
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

1. Go to google cloud console
2. create a project
3. go to api & services --> Oauth Consent screen --> fil all the details(app name, scopes, testing user .. etc)
4. go to api & service --> credentials
    - select aplicaiton type
    - application name
    - authorise javascript origin //domains which is accessible from all sub domains
    - authrisation redirect uris // after login the credentials will be passed to backend url
        default redirect url - http://localhost:8080/login/oauth2/code/google
    - create

- add client and secret in application.properties
5. add oauth2login in websecurityconfig class
6. create oauth2successhandler
7.